{"ast":null,"code":"import sync, { flushSync } from 'framesync';\nimport { withoutTreeTransform, batchResetAndMeasure } from '../../../render/dom/projection/utils.js';\nimport { compareByDepth } from '../../../render/utils/compare-by-depth.js';\nimport { Presence } from '../types.js';\n/**\n * Default handlers for batching VisualElements\n */\n\nvar defaultHandler = {\n  layoutReady: function layoutReady(child) {\n    return child.notifyLayoutReady();\n  }\n};\n/**\n * Create a batcher to process VisualElements\n */\n\nfunction createBatcher() {\n  var queue = new Set();\n  return {\n    add: function add(child) {\n      return queue.add(child);\n    },\n    flush: function flush(_a) {\n      var _b = _a === void 0 ? defaultHandler : _a,\n          layoutReady = _b.layoutReady,\n          parent = _b.parent;\n\n      var order = Array.from(queue).sort(compareByDepth);\n\n      if (parent) {\n        withoutTreeTransform(parent, function () {\n          batchResetAndMeasure(order);\n        });\n      } else {\n        batchResetAndMeasure(order);\n      }\n      /**\n       * Write: Notify the VisualElements they're ready for further write operations.\n       */\n\n\n      order.forEach(layoutReady);\n      /**\n       * After all children have started animating, ensure any Entering components are set to Present.\n       * If we add deferred animations (set up all animations and then start them in two loops) this\n       * could be moved to the start loop. But it needs to happen after all the animations configs\n       * are generated in AnimateSharedLayout as this relies on presence data\n       */\n\n      order.forEach(function (child) {\n        if (child.isPresent) child.presence = Presence.Present;\n      });\n      /**\n       * Starting these animations will have queued jobs on the frame loop. In some situations,\n       * like when removing an element, these will be processed too late after the DOM is manipulated,\n       * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n       * we ensure there's no flash.\n       */\n\n      flushSync.preRender();\n      flushSync.render();\n      /**\n       * Schedule a callback at the end of the following frame to assign the latest projection\n       * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n       * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n       * child attempts to calculate its previous relative position against a prevViewportBox\n       * it will be against its latest projection box instead, as the snapshot is useless beyond this\n       * render.\n       */\n\n      sync.postRender(function () {\n        return order.forEach(assignProjectionToSnapshot);\n      });\n      queue.clear();\n    }\n  };\n}\n\nfunction assignProjectionToSnapshot(child) {\n  child.prevViewportBox = child.projection.target;\n}\n\nexport { createBatcher };","map":{"version":3,"names":["sync","flushSync","withoutTreeTransform","batchResetAndMeasure","compareByDepth","Presence","defaultHandler","layoutReady","child","notifyLayoutReady","createBatcher","queue","Set","add","flush","_a","_b","parent","order","Array","from","sort","forEach","isPresent","presence","Present","preRender","render","postRender","assignProjectionToSnapshot","clear","prevViewportBox","projection","target"],"sources":["D:/Coding/Web Development/portfolio/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/batcher.js"],"sourcesContent":["import sync, { flushSync } from 'framesync';\nimport { withoutTreeTransform, batchResetAndMeasure } from '../../../render/dom/projection/utils.js';\nimport { compareByDepth } from '../../../render/utils/compare-by-depth.js';\nimport { Presence } from '../types.js';\n\n/**\n * Default handlers for batching VisualElements\n */\nvar defaultHandler = {\n    layoutReady: function (child) { return child.notifyLayoutReady(); },\n};\n/**\n * Create a batcher to process VisualElements\n */\nfunction createBatcher() {\n    var queue = new Set();\n    return {\n        add: function (child) { return queue.add(child); },\n        flush: function (_a) {\n            var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;\n            var order = Array.from(queue).sort(compareByDepth);\n            if (parent) {\n                withoutTreeTransform(parent, function () {\n                    batchResetAndMeasure(order);\n                });\n            }\n            else {\n                batchResetAndMeasure(order);\n            }\n            /**\n             * Write: Notify the VisualElements they're ready for further write operations.\n             */\n            order.forEach(layoutReady);\n            /**\n             * After all children have started animating, ensure any Entering components are set to Present.\n             * If we add deferred animations (set up all animations and then start them in two loops) this\n             * could be moved to the start loop. But it needs to happen after all the animations configs\n             * are generated in AnimateSharedLayout as this relies on presence data\n             */\n            order.forEach(function (child) {\n                if (child.isPresent)\n                    child.presence = Presence.Present;\n            });\n            /**\n             * Starting these animations will have queued jobs on the frame loop. In some situations,\n             * like when removing an element, these will be processed too late after the DOM is manipulated,\n             * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n             * we ensure there's no flash.\n             */\n            flushSync.preRender();\n            flushSync.render();\n            /**\n             * Schedule a callback at the end of the following frame to assign the latest projection\n             * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n             * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n             * child attempts to calculate its previous relative position against a prevViewportBox\n             * it will be against its latest projection box instead, as the snapshot is useless beyond this\n             * render.\n             */\n            sync.postRender(function () { return order.forEach(assignProjectionToSnapshot); });\n            queue.clear();\n        },\n    };\n}\nfunction assignProjectionToSnapshot(child) {\n    child.prevViewportBox = child.projection.target;\n}\n\nexport { createBatcher };\n"],"mappings":"AAAA,OAAOA,IAAP,IAAeC,SAAf,QAAgC,WAAhC;AACA,SAASC,oBAAT,EAA+BC,oBAA/B,QAA2D,yCAA3D;AACA,SAASC,cAAT,QAA+B,2CAA/B;AACA,SAASC,QAAT,QAAyB,aAAzB;AAEA;AACA;AACA;;AACA,IAAIC,cAAc,GAAG;EACjBC,WAAW,EAAE,qBAAUC,KAAV,EAAiB;IAAE,OAAOA,KAAK,CAACC,iBAAN,EAAP;EAAmC;AADlD,CAArB;AAGA;AACA;AACA;;AACA,SAASC,aAAT,GAAyB;EACrB,IAAIC,KAAK,GAAG,IAAIC,GAAJ,EAAZ;EACA,OAAO;IACHC,GAAG,EAAE,aAAUL,KAAV,EAAiB;MAAE,OAAOG,KAAK,CAACE,GAAN,CAAUL,KAAV,CAAP;IAA0B,CAD/C;IAEHM,KAAK,EAAE,eAAUC,EAAV,EAAc;MACjB,IAAIC,EAAE,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgBT,cAAhB,GAAiCS,EAA1C;MAAA,IAA8CR,WAAW,GAAGS,EAAE,CAACT,WAA/D;MAAA,IAA4EU,MAAM,GAAGD,EAAE,CAACC,MAAxF;;MACA,IAAIC,KAAK,GAAGC,KAAK,CAACC,IAAN,CAAWT,KAAX,EAAkBU,IAAlB,CAAuBjB,cAAvB,CAAZ;;MACA,IAAIa,MAAJ,EAAY;QACRf,oBAAoB,CAACe,MAAD,EAAS,YAAY;UACrCd,oBAAoB,CAACe,KAAD,CAApB;QACH,CAFmB,CAApB;MAGH,CAJD,MAKK;QACDf,oBAAoB,CAACe,KAAD,CAApB;MACH;MACD;AACZ;AACA;;;MACYA,KAAK,CAACI,OAAN,CAAcf,WAAd;MACA;AACZ;AACA;AACA;AACA;AACA;;MACYW,KAAK,CAACI,OAAN,CAAc,UAAUd,KAAV,EAAiB;QAC3B,IAAIA,KAAK,CAACe,SAAV,EACIf,KAAK,CAACgB,QAAN,GAAiBnB,QAAQ,CAACoB,OAA1B;MACP,CAHD;MAIA;AACZ;AACA;AACA;AACA;AACA;;MACYxB,SAAS,CAACyB,SAAV;MACAzB,SAAS,CAAC0B,MAAV;MACA;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;MACY3B,IAAI,CAAC4B,UAAL,CAAgB,YAAY;QAAE,OAAOV,KAAK,CAACI,OAAN,CAAcO,0BAAd,CAAP;MAAmD,CAAjF;MACAlB,KAAK,CAACmB,KAAN;IACH;EA7CE,CAAP;AA+CH;;AACD,SAASD,0BAAT,CAAoCrB,KAApC,EAA2C;EACvCA,KAAK,CAACuB,eAAN,GAAwBvB,KAAK,CAACwB,UAAN,CAAiBC,MAAzC;AACH;;AAED,SAASvB,aAAT"},"metadata":{},"sourceType":"module"}