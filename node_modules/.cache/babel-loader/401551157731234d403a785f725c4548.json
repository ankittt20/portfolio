{"ast":null,"code":"import { __assign, __spreadArray, __read } from 'tslib';\nimport sync, { cancelSync } from 'framesync';\nimport { pipe } from 'popmotion';\nimport { Presence } from '../components/AnimateSharedLayout/types.js';\nimport { eachAxis } from '../utils/each-axis.js';\nimport { axisBox } from '../utils/geometry/index.js';\nimport { removeBoxTransforms, applyBoxTransforms } from '../utils/geometry/delta-apply.js';\nimport { calcRelativeBox, updateBoxDelta } from '../utils/geometry/delta-calc.js';\nimport { motionValue } from '../value/index.js';\nimport { isMotionValue } from '../value/utils/is-motion-value.js';\nimport { buildLayoutProjectionTransform } from './html/utils/build-projection-transform.js';\nimport { variantPriorityOrder } from './utils/animation-state.js';\nimport { createLifecycles } from './utils/lifecycles.js';\nimport { updateMotionValuesFromProps } from './utils/motion-values.js';\nimport { updateLayoutDeltas } from './utils/projection.js';\nimport { createLayoutState, createProjectionState } from './utils/state.js';\nimport { FlatTree } from './utils/flat-tree.js';\nimport { checkIfControllingVariants, checkIfVariantNode, isVariantLabel } from './utils/variants.js';\nimport { setCurrentViewportBox } from './dom/projection/relative-set.js';\n\nvar visualElement = function visualElement(_a) {\n  var _b = _a.treeType,\n      treeType = _b === void 0 ? \"\" : _b,\n      build = _a.build,\n      _getBaseTarget = _a.getBaseTarget,\n      _makeTargetAnimatable = _a.makeTargetAnimatable,\n      _measureViewportBox = _a.measureViewportBox,\n      renderInstance = _a.render,\n      readValueFromInstance = _a.readValueFromInstance,\n      _resetTransform = _a.resetTransform,\n      _restoreTransform = _a.restoreTransform,\n      removeValueFromRenderState = _a.removeValueFromRenderState,\n      _sortNodePosition = _a.sortNodePosition,\n      scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n  return function (_a, options) {\n    var parent = _a.parent,\n        props = _a.props,\n        presenceId = _a.presenceId,\n        blockInitialAnimation = _a.blockInitialAnimation,\n        visualState = _a.visualState;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var latestValues = visualState.latestValues,\n        renderState = visualState.renderState;\n    /**\n     * The instance of the render-specific node that will be hydrated by the\n     * exposed React ref. So for example, this visual element can host a\n     * HTMLElement, plain object, or Three.js object. The functions provided\n     * in VisualElementConfig allow us to interface with this instance.\n     */\n\n    var instance;\n    /**\n     * Manages the subscriptions for a visual element's lifecycle, for instance\n     * onRender and onViewportBoxUpdate.\n     */\n\n    var lifecycles = createLifecycles();\n    /**\n     *\n     */\n\n    var projection = createProjectionState();\n    /**\n     * A reference to the nearest projecting parent. This is either\n     * undefined if we haven't looked for the nearest projecting parent,\n     * false if there is no parent performing layout projection, or a reference\n     * to the projecting parent.\n     */\n\n    var projectionParent;\n    /**\n     * This is a reference to the visual state of the \"lead\" visual element.\n     * Usually, this will be this visual element. But if it shares a layoutId\n     * with other visual elements, only one of them will be designated lead by\n     * AnimateSharedLayout. All the other visual elements will take on the visual\n     * appearance of the lead while they crossfade to it.\n     */\n\n    var leadProjection = projection;\n    var leadLatestValues = latestValues;\n    var unsubscribeFromLeadVisualElement;\n    /**\n     * The latest layout measurements and calculated projections. This\n     * is seperate from the target projection data in visualState as\n     * many visual elements might point to the same piece of visualState as\n     * a target, whereas they might each have different layouts and thus\n     * projection calculations needed to project into the same viewport box.\n     */\n\n    var layoutState = createLayoutState();\n    /**\n     *\n     */\n\n    var crossfader;\n    /**\n     * Keep track of whether the viewport box has been updated since the\n     * last time the layout projection was re-calculated.\n     */\n\n    var hasViewportBoxUpdated = false;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n\n    var values = new Map();\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n\n    var valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n\n    var prevMotionValues = {};\n    /**\n     * x/y motion values that track the progress of initiated layout\n     * animations.\n     *\n     * TODO: Target for removal\n     */\n\n    var projectionTargetProgress;\n    /**\n     * When values are removed from all animation props we need to search\n     * for a fallback value to animate to. These values are tracked in baseTarget.\n     */\n\n    var baseTarget = __assign({}, latestValues); // Internal methods ========================\n\n    /**\n     * On mount, this will be hydrated with a callback to disconnect\n     * this visual element from its parent on unmount.\n     */\n\n\n    var removeFromVariantTree;\n    /**\n     *\n     */\n\n    function render() {\n      if (!instance) return;\n\n      if (element.isProjecting()) {\n        /**\n         * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n         * This is the final box that we will then project into by calculating a transform delta and\n         * applying it to the corrected box.\n         */\n        applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\n        /**\n         * Update the delta between the corrected box and the final target box, after\n         * user-set transforms are applied to it. This will be used by the renderer to\n         * create a transform style that will reproject the element from its actual layout\n         * into the desired bounding box.\n         */\n\n        updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\n      }\n\n      triggerBuild();\n      renderInstance(instance, renderState);\n    }\n\n    function triggerBuild() {\n      var valuesToRender = latestValues;\n\n      if (crossfader && crossfader.isActive()) {\n        var crossfadedValues = crossfader.getCrossfadeState(element);\n        if (crossfadedValues) valuesToRender = crossfadedValues;\n      }\n\n      build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\n    }\n\n    function update() {\n      lifecycles.notifyUpdate(latestValues);\n    }\n\n    function updateLayoutProjection() {\n      var delta = layoutState.delta,\n          treeScale = layoutState.treeScale;\n      var prevTreeScaleX = treeScale.x;\n      var prevTreeScaleY = treeScale.x;\n      var prevDeltaTransform = layoutState.deltaTransform;\n      updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\n      hasViewportBoxUpdated && element.notifyViewportBoxUpdate(leadProjection.target, delta);\n      hasViewportBoxUpdated = false;\n      var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\n\n      if (deltaTransform !== prevDeltaTransform || // Also compare calculated treeScale, for values that rely on this only for scale correction\n      prevTreeScaleX !== treeScale.x || prevTreeScaleY !== treeScale.y) {\n        element.scheduleRender();\n      }\n\n      layoutState.deltaTransform = deltaTransform;\n    }\n\n    function _updateTreeLayoutProjection() {\n      element.layoutTree.forEach(fireUpdateLayoutProjection);\n    }\n    /**\n     *\n     */\n\n\n    function bindToMotionValue(key, value) {\n      var removeOnChange = value.onChange(function (latestValue) {\n        latestValues[key] = latestValue;\n        props.onUpdate && sync.update(update, false, true);\n      });\n      var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n      valueSubscriptions.set(key, function () {\n        removeOnChange();\n        removeOnRenderRequest();\n      });\n    }\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't neccessarily a breaking change,\n     * more a reflection of the test.\n     */\n\n\n    var initialMotionValues = scrapeMotionValuesFromProps(props);\n\n    for (var key in initialMotionValues) {\n      var value = initialMotionValues[key];\n\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n      }\n    }\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n\n\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n\n    var element = __assign(__assign({\n      treeType: treeType,\n\n      /**\n       * This is a mirror of the internal instance prop, which keeps\n       * VisualElement type-compatible with React's RefObject.\n       */\n      current: null,\n\n      /**\n       * The depth of this visual element within the visual element tree.\n       */\n      depth: parent ? parent.depth + 1 : 0,\n      parent: parent,\n      children: new Set(),\n\n      /**\n       * An ancestor path back to the root visual element. This is used\n       * by layout projection to quickly recurse back up the tree.\n       */\n      path: parent ? __spreadArray(__spreadArray([], __read(parent.path)), [parent]) : [],\n      layoutTree: parent ? parent.layoutTree : new FlatTree(),\n\n      /**\n       *\n       */\n      presenceId: presenceId,\n      projection: projection,\n\n      /**\n       * If this component is part of the variant tree, it should track\n       * any children that are also part of the tree. This is essentially\n       * a shadow tree to simplify logic around how to stagger over children.\n       */\n      variantChildren: isVariantNode ? new Set() : undefined,\n\n      /**\n       * Whether this instance is visible. This can be changed imperatively\n       * by AnimateSharedLayout, is analogous to CSS's visibility in that\n       * hidden elements should take up layout, and needs enacting by the configured\n       * render function.\n       */\n      isVisible: undefined,\n\n      /**\n       * Normally, if a component is controlled by a parent's variants, it can\n       * rely on that ancestor to trigger animations further down the tree.\n       * However, if a component is created after its parent is mounted, the parent\n       * won't trigger that mount animation so the child needs to.\n       *\n       * TODO: This might be better replaced with a method isParentMounted\n       */\n      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),\n\n      /**\n       * This can be set by AnimatePresence to force components that mount\n       * at the same time as it to mount as if they have initial={false} set.\n       */\n      blockInitialAnimation: blockInitialAnimation,\n\n      /**\n       * A boolean that can be used to determine whether to respect hover events.\n       * For layout measurements we often have to reposition the instance by\n       * removing its transform. This can trigger hover events, which is\n       * undesired.\n       */\n      isHoverEventsEnabled: true,\n\n      /**\n       * Determine whether this component has mounted yet. This is mostly used\n       * by variant children to determine whether they need to trigger their\n       * own animations on mount.\n       */\n      isMounted: function isMounted() {\n        return Boolean(instance);\n      },\n      mount: function mount(newInstance) {\n        instance = element.current = newInstance;\n        element.pointTo(element);\n\n        if (isVariantNode && parent && !isControllingVariants) {\n          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n        }\n\n        parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n      },\n\n      /**\n       *\n       */\n      unmount: function unmount() {\n        cancelSync.update(update);\n        cancelSync.render(render);\n        cancelSync.preRender(element.updateLayoutProjection);\n        valueSubscriptions.forEach(function (remove) {\n          return remove();\n        });\n        element.stopLayoutAnimation();\n        element.layoutTree.remove(element);\n        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        lifecycles.clearAllListeners();\n      },\n\n      /**\n       * Add a child visual element to our set of children.\n       */\n      addVariantChild: function addVariantChild(child) {\n        var _a;\n\n        var closestVariantNode = element.getClosestVariantNode();\n\n        if (closestVariantNode) {\n          (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n          return function () {\n            return closestVariantNode.variantChildren.delete(child);\n          };\n        }\n      },\n      sortNodePosition: function sortNodePosition(other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!_sortNodePosition || treeType !== other.treeType) return 0;\n        return _sortNodePosition(element.getInstance(), other.getInstance());\n      },\n\n      /**\n       * Returns the closest variant node in the tree starting from\n       * this visual element.\n       */\n      getClosestVariantNode: function getClosestVariantNode() {\n        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n      },\n\n      /**\n       * A method that schedules an update to layout projections throughout\n       * the tree. We inherit from the parent so there's only ever one\n       * job scheduled on the next frame - that of the root visual element.\n       */\n      scheduleUpdateLayoutProjection: parent ? parent.scheduleUpdateLayoutProjection : function () {\n        return sync.preRender(element.updateTreeLayoutProjection, false, true);\n      },\n\n      /**\n       * Expose the latest layoutId prop.\n       */\n      getLayoutId: function getLayoutId() {\n        return props.layoutId;\n      },\n\n      /**\n       * Returns the current instance.\n       */\n      getInstance: function getInstance() {\n        return instance;\n      },\n\n      /**\n       * Get/set the latest static values.\n       */\n      getStaticValue: function getStaticValue(key) {\n        return latestValues[key];\n      },\n      setStaticValue: function setStaticValue(key, value) {\n        return latestValues[key] = value;\n      },\n\n      /**\n       * Returns the latest motion value state. Currently only used to take\n       * a snapshot of the visual element - perhaps this can return the whole\n       * visual state\n       */\n      getLatestValues: function getLatestValues() {\n        return latestValues;\n      },\n\n      /**\n       * Set the visiblity of the visual element. If it's changed, schedule\n       * a render to reflect these changes.\n       */\n      setVisibility: function setVisibility(visibility) {\n        if (element.isVisible === visibility) return;\n        element.isVisible = visibility;\n        element.scheduleRender();\n      },\n\n      /**\n       * Make a target animatable by Popmotion. For instance, if we're\n       * trying to animate width from 100px to 100vw we need to measure 100vw\n       * in pixels to determine what we really need to animate to. This is also\n       * pluggable to support Framer's custom value types like Color,\n       * and CSS variables.\n       */\n      makeTargetAnimatable: function makeTargetAnimatable(target, canMutate) {\n        if (canMutate === void 0) {\n          canMutate = true;\n        }\n\n        return _makeTargetAnimatable(element, target, props, canMutate);\n      },\n\n      /**\n       * Temporarily suspend hover events while we remove transforms in order to measure the layout.\n       *\n       * This seems like an odd bit of scheduling but what we're doing is saying after\n       * the next render, wait 10 milliseconds before reenabling hover events. Waiting until\n       * the next frame results in missed, valid hover events. But triggering on the postRender\n       * frame is too soon to avoid triggering events with layout measurements.\n       *\n       * Note: If we figure out a way of measuring layout while transforms remain applied, this can be removed.\n       */\n      suspendHoverEvents: function suspendHoverEvents() {\n        element.isHoverEventsEnabled = false;\n        sync.postRender(function () {\n          return setTimeout(function () {\n            return element.isHoverEventsEnabled = true;\n          }, 10);\n        });\n      },\n      // Motion values ========================\n\n      /**\n       * Add a motion value and bind it to this visual element.\n       */\n      addValue: function addValue(key, value) {\n        // Remove existing value if it exists\n        if (element.hasValue(key)) element.removeValue(key);\n        values.set(key, value);\n        latestValues[key] = value.get();\n        bindToMotionValue(key, value);\n      },\n\n      /**\n       * Remove a motion value and unbind any active subscriptions.\n       */\n      removeValue: function removeValue(key) {\n        var _a;\n\n        values.delete(key);\n        (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n        valueSubscriptions.delete(key);\n        delete latestValues[key];\n        removeValueFromRenderState(key, renderState);\n      },\n\n      /**\n       * Check whether we have a motion value for this key\n       */\n      hasValue: function hasValue(key) {\n        return values.has(key);\n      },\n\n      /**\n       * Get a motion value for this key. If called with a default\n       * value, we'll create one if none exists.\n       */\n      getValue: function getValue(key, defaultValue) {\n        var value = values.get(key);\n\n        if (value === undefined && defaultValue !== undefined) {\n          value = motionValue(defaultValue);\n          element.addValue(key, value);\n        }\n\n        return value;\n      },\n\n      /**\n       * Iterate over our motion values.\n       */\n      forEachValue: function forEachValue(callback) {\n        return values.forEach(callback);\n      },\n\n      /**\n       * If we're trying to animate to a previously unencountered value,\n       * we need to check for it in our state and as a last resort read it\n       * directly from the instance (which might have performance implications).\n       */\n      readValue: function readValue(key) {\n        var _a;\n\n        return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n      },\n\n      /**\n       * Set the base target to later animate back to. This is currently\n       * only hydrated on creation and when we first read a value.\n       */\n      setBaseTarget: function setBaseTarget(key, value) {\n        baseTarget[key] = value;\n      },\n\n      /**\n       * Find the base target for a value thats been removed from all animation\n       * props.\n       */\n      getBaseTarget: function getBaseTarget(key) {\n        if (_getBaseTarget) {\n          var target = _getBaseTarget(props, key);\n\n          if (target !== undefined && !isMotionValue(target)) return target;\n        }\n\n        return baseTarget[key];\n      }\n    }, lifecycles), {\n      /**\n       * Build the renderer state based on the latest visual state.\n       */\n      build: function build() {\n        triggerBuild();\n        return renderState;\n      },\n\n      /**\n       * Schedule a render on the next animation frame.\n       */\n      scheduleRender: function scheduleRender() {\n        sync.render(render, false, true);\n      },\n\n      /**\n       * Synchronously fire render. It's prefered that we batch renders but\n       * in many circumstances, like layout measurement, we need to run this\n       * synchronously. However in those instances other measures should be taken\n       * to batch reads/writes.\n       */\n      syncRender: render,\n\n      /**\n       * Update the provided props. Ensure any newly-added motion values are\n       * added to our map, old ones removed, and listeners updated.\n       */\n      setProps: function setProps(newProps) {\n        props = newProps;\n        lifecycles.updatePropListeners(newProps);\n        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n      },\n      getProps: function getProps() {\n        return props;\n      },\n      // Variants ==============================\n\n      /**\n       * Returns the variant definition with a given name.\n       */\n      getVariant: function getVariant(name) {\n        var _a;\n\n        return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name];\n      },\n\n      /**\n       * Returns the defined default transition on this component.\n       */\n      getDefaultTransition: function getDefaultTransition() {\n        return props.transition;\n      },\n\n      /**\n       * Used by child variant nodes to get the closest ancestor variant props.\n       */\n      getVariantContext: function getVariantContext(startAtParent) {\n        if (startAtParent === void 0) {\n          startAtParent = false;\n        }\n\n        if (startAtParent) return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n\n        if (!isControllingVariants) {\n          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n\n          if (props.initial !== undefined) {\n            context_1.initial = props.initial;\n          }\n\n          return context_1;\n        }\n\n        var context = {};\n\n        for (var i = 0; i < numVariantProps; i++) {\n          var name_1 = variantProps[i];\n          var prop = props[name_1];\n\n          if (isVariantLabel(prop) || prop === false) {\n            context[name_1] = prop;\n          }\n        }\n\n        return context;\n      },\n      // Layout projection ==============================\n\n      /**\n       * Enable layout projection for this visual element. Won't actually\n       * occur until we also have hydrated layout measurements.\n       */\n      enableLayoutProjection: function enableLayoutProjection() {\n        projection.isEnabled = true;\n        element.layoutTree.add(element);\n      },\n\n      /**\n       * Lock the projection target, for instance when dragging, so\n       * nothing else can try and animate it.\n       */\n      lockProjectionTarget: function lockProjectionTarget() {\n        projection.isTargetLocked = true;\n      },\n      unlockProjectionTarget: function unlockProjectionTarget() {\n        element.stopLayoutAnimation();\n        projection.isTargetLocked = false;\n      },\n      getLayoutState: function getLayoutState() {\n        return layoutState;\n      },\n      setCrossfader: function setCrossfader(newCrossfader) {\n        crossfader = newCrossfader;\n      },\n      isProjecting: function isProjecting() {\n        return projection.isEnabled && layoutState.isHydrated;\n      },\n\n      /**\n       * Start a layout animation on a given axis.\n       */\n      startLayoutAnimation: function startLayoutAnimation(axis, transition, isRelative) {\n        if (isRelative === void 0) {\n          isRelative = false;\n        }\n\n        var progress = element.getProjectionAnimationProgress()[axis];\n\n        var _a = isRelative ? projection.relativeTarget[axis] : projection.target[axis],\n            min = _a.min,\n            max = _a.max;\n\n        var length = max - min;\n        progress.clearListeners();\n        progress.set(min);\n        progress.set(min); // Set twice to hard-reset velocity\n\n        progress.onChange(function (v) {\n          element.setProjectionTargetAxis(axis, v, v + length, isRelative);\n        });\n        return element.animateMotionValue(axis, progress, 0, transition);\n      },\n\n      /**\n       * Stop layout animations.\n       */\n      stopLayoutAnimation: function stopLayoutAnimation() {\n        eachAxis(function (axis) {\n          return element.getProjectionAnimationProgress()[axis].stop();\n        });\n      },\n\n      /**\n       * Measure the current viewport box with or without transforms.\n       * Only measures axis-aligned boxes, rotate and skew must be manually\n       * removed with a re-render to work.\n       */\n      measureViewportBox: function measureViewportBox(withTransform) {\n        if (withTransform === void 0) {\n          withTransform = true;\n        }\n\n        var viewportBox = _measureViewportBox(instance, options);\n\n        if (!withTransform) removeBoxTransforms(viewportBox, latestValues);\n        return viewportBox;\n      },\n\n      /**\n       * Get the motion values tracking the layout animations on each\n       * axis. Lazy init if not already created.\n       */\n      getProjectionAnimationProgress: function getProjectionAnimationProgress() {\n        projectionTargetProgress || (projectionTargetProgress = {\n          x: motionValue(0),\n          y: motionValue(0)\n        });\n        return projectionTargetProgress;\n      },\n\n      /**\n       * Update the projection of a single axis. Schedule an update to\n       * the tree layout projection.\n       */\n      setProjectionTargetAxis: function setProjectionTargetAxis(axis, min, max, isRelative) {\n        if (isRelative === void 0) {\n          isRelative = false;\n        }\n\n        var target;\n\n        if (isRelative) {\n          if (!projection.relativeTarget) {\n            projection.relativeTarget = axisBox();\n          }\n\n          target = projection.relativeTarget[axis];\n        } else {\n          projection.relativeTarget = undefined;\n          target = projection.target[axis];\n        }\n\n        target.min = min;\n        target.max = max; // Flag that we want to fire the onViewportBoxUpdate event handler\n\n        hasViewportBoxUpdated = true;\n        lifecycles.notifySetAxisTarget();\n      },\n\n      /**\n       * Rebase the projection target on top of the provided viewport box\n       * or the measured layout. This ensures that non-animating elements\n       * don't fall out of sync differences in measurements vs projections\n       * after a page scroll or other relayout.\n       */\n      rebaseProjectionTarget: function rebaseProjectionTarget(force, box) {\n        if (box === void 0) {\n          box = layoutState.layout;\n        }\n\n        var _a = element.getProjectionAnimationProgress(),\n            x = _a.x,\n            y = _a.y;\n\n        var shouldRebase = !projection.relativeTarget && !projection.isTargetLocked && !x.isAnimating() && !y.isAnimating();\n\n        if (force || shouldRebase) {\n          eachAxis(function (axis) {\n            var _a = box[axis],\n                min = _a.min,\n                max = _a.max;\n            element.setProjectionTargetAxis(axis, min, max);\n          });\n        }\n      },\n\n      /**\n       * Notify the visual element that its layout is up-to-date.\n       * Currently Animate.tsx uses this to check whether a layout animation\n       * needs to be performed.\n       */\n      notifyLayoutReady: function notifyLayoutReady(config) {\n        setCurrentViewportBox(element);\n        element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\n      },\n\n      /**\n       * Temporarily reset the transform of the instance.\n       */\n      resetTransform: function resetTransform() {\n        return _resetTransform(element, instance, props);\n      },\n      restoreTransform: function restoreTransform() {\n        return _restoreTransform(instance, renderState);\n      },\n      updateLayoutProjection: updateLayoutProjection,\n      updateTreeLayoutProjection: function updateTreeLayoutProjection() {\n        element.layoutTree.forEach(fireResolveRelativeTargetBox);\n        /**\n         * Schedule the projection updates at the end of the current preRender\n         * step. This will ensure that all layout trees will first resolve\n         * relative projection boxes into viewport boxes, and *then*\n         * update projections.\n         */\n\n        sync.preRender(_updateTreeLayoutProjection, false, true);\n      },\n      getProjectionParent: function getProjectionParent() {\n        if (projectionParent === undefined) {\n          var foundParent = false; // Search backwards through the tree path\n\n          for (var i = element.path.length - 1; i >= 0; i--) {\n            var ancestor = element.path[i];\n\n            if (ancestor.projection.isEnabled) {\n              foundParent = ancestor;\n              break;\n            }\n          }\n\n          projectionParent = foundParent;\n        }\n\n        return projectionParent;\n      },\n      resolveRelativeTargetBox: function resolveRelativeTargetBox() {\n        var relativeParent = element.getProjectionParent();\n        if (!projection.relativeTarget || !relativeParent) return;\n        calcRelativeBox(projection, relativeParent.projection);\n\n        if (relativeParent.getProps().drag) {\n          var target = projection.target;\n          applyBoxTransforms(target, target, relativeParent.getLatestValues());\n        }\n      },\n\n      /**\n       *\n       */\n      pointTo: function pointTo(newLead) {\n        leadProjection = newLead.projection;\n        leadLatestValues = newLead.getLatestValues();\n        /**\n         * Subscribe to lead component's layout animations\n         */\n\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        unsubscribeFromLeadVisualElement = pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\n          var _a;\n\n          if (element.isPresent) {\n            element.presence = Presence.Present;\n          } else {\n            (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\n          }\n        }));\n      },\n      // TODO: Clean this up\n      isPresent: true,\n      presence: Presence.Entering\n    });\n\n    return element;\n  };\n};\n\nfunction fireResolveRelativeTargetBox(child) {\n  child.resolveRelativeTargetBox();\n}\n\nfunction fireUpdateLayoutProjection(child) {\n  child.updateLayoutProjection();\n}\n\nvar variantProps = __spreadArray([\"initial\"], __read(variantPriorityOrder));\n\nvar numVariantProps = variantProps.length;\nexport { visualElement };","map":{"version":3,"names":["__assign","__spreadArray","__read","sync","cancelSync","pipe","Presence","eachAxis","axisBox","removeBoxTransforms","applyBoxTransforms","calcRelativeBox","updateBoxDelta","motionValue","isMotionValue","buildLayoutProjectionTransform","variantPriorityOrder","createLifecycles","updateMotionValuesFromProps","updateLayoutDeltas","createLayoutState","createProjectionState","FlatTree","checkIfControllingVariants","checkIfVariantNode","isVariantLabel","setCurrentViewportBox","visualElement","_a","_b","treeType","build","getBaseTarget","makeTargetAnimatable","measureViewportBox","renderInstance","render","readValueFromInstance","resetTransform","restoreTransform","removeValueFromRenderState","sortNodePosition","scrapeMotionValuesFromProps","options","parent","props","presenceId","blockInitialAnimation","visualState","latestValues","renderState","instance","lifecycles","projection","projectionParent","leadProjection","leadLatestValues","unsubscribeFromLeadVisualElement","layoutState","crossfader","hasViewportBoxUpdated","values","Map","valueSubscriptions","prevMotionValues","projectionTargetProgress","baseTarget","removeFromVariantTree","element","isProjecting","targetFinal","target","deltaFinal","layoutCorrected","triggerBuild","valuesToRender","isActive","crossfadedValues","getCrossfadeState","update","notifyUpdate","updateLayoutProjection","delta","treeScale","prevTreeScaleX","x","prevTreeScaleY","prevDeltaTransform","deltaTransform","path","notifyViewportBoxUpdate","y","scheduleRender","updateTreeLayoutProjection","layoutTree","forEach","fireUpdateLayoutProjection","bindToMotionValue","key","value","removeOnChange","onChange","latestValue","onUpdate","removeOnRenderRequest","onRenderRequest","set","initialMotionValues","undefined","isControllingVariants","isVariantNode","current","depth","children","Set","variantChildren","isVisible","manuallyAnimateOnMount","Boolean","isMounted","isHoverEventsEnabled","mount","newInstance","pointTo","addVariantChild","add","unmount","preRender","remove","stopLayoutAnimation","delete","clearAllListeners","child","closestVariantNode","getClosestVariantNode","other","getInstance","scheduleUpdateLayoutProjection","getLayoutId","layoutId","getStaticValue","setStaticValue","getLatestValues","setVisibility","visibility","canMutate","suspendHoverEvents","postRender","setTimeout","addValue","hasValue","removeValue","get","has","getValue","defaultValue","forEachValue","callback","readValue","setBaseTarget","syncRender","setProps","newProps","updatePropListeners","getProps","getVariant","name","variants","getDefaultTransition","transition","getVariantContext","startAtParent","context_1","initial","context","i","numVariantProps","name_1","variantProps","prop","enableLayoutProjection","isEnabled","lockProjectionTarget","isTargetLocked","unlockProjectionTarget","getLayoutState","setCrossfader","newCrossfader","isHydrated","startLayoutAnimation","axis","isRelative","progress","getProjectionAnimationProgress","relativeTarget","min","max","length","clearListeners","v","setProjectionTargetAxis","animateMotionValue","stop","withTransform","viewportBox","notifySetAxisTarget","rebaseProjectionTarget","force","box","layout","shouldRebase","isAnimating","notifyLayoutReady","config","notifyLayoutUpdate","prevViewportBox","fireResolveRelativeTargetBox","getProjectionParent","foundParent","ancestor","resolveRelativeTargetBox","relativeParent","drag","newLead","onSetAxisTarget","onLayoutAnimationComplete","isPresent","presence","Present","layoutSafeToRemove","call","Entering"],"sources":["D:/Coding/Web Development/portfolio/node_modules/framer-motion/dist/es/render/index.js"],"sourcesContent":["import { __assign, __spreadArray, __read } from 'tslib';\nimport sync, { cancelSync } from 'framesync';\nimport { pipe } from 'popmotion';\nimport { Presence } from '../components/AnimateSharedLayout/types.js';\nimport { eachAxis } from '../utils/each-axis.js';\nimport { axisBox } from '../utils/geometry/index.js';\nimport { removeBoxTransforms, applyBoxTransforms } from '../utils/geometry/delta-apply.js';\nimport { calcRelativeBox, updateBoxDelta } from '../utils/geometry/delta-calc.js';\nimport { motionValue } from '../value/index.js';\nimport { isMotionValue } from '../value/utils/is-motion-value.js';\nimport { buildLayoutProjectionTransform } from './html/utils/build-projection-transform.js';\nimport { variantPriorityOrder } from './utils/animation-state.js';\nimport { createLifecycles } from './utils/lifecycles.js';\nimport { updateMotionValuesFromProps } from './utils/motion-values.js';\nimport { updateLayoutDeltas } from './utils/projection.js';\nimport { createLayoutState, createProjectionState } from './utils/state.js';\nimport { FlatTree } from './utils/flat-tree.js';\nimport { checkIfControllingVariants, checkIfVariantNode, isVariantLabel } from './utils/variants.js';\nimport { setCurrentViewportBox } from './dom/projection/relative-set.js';\n\nvar visualElement = function (_a) {\n    var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n    return function (_a, options) {\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState;\n        if (options === void 0) { options = {}; }\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\n        /**\n         * The instance of the render-specific node that will be hydrated by the\n         * exposed React ref. So for example, this visual element can host a\n         * HTMLElement, plain object, or Three.js object. The functions provided\n         * in VisualElementConfig allow us to interface with this instance.\n         */\n        var instance;\n        /**\n         * Manages the subscriptions for a visual element's lifecycle, for instance\n         * onRender and onViewportBoxUpdate.\n         */\n        var lifecycles = createLifecycles();\n        /**\n         *\n         */\n        var projection = createProjectionState();\n        /**\n         * A reference to the nearest projecting parent. This is either\n         * undefined if we haven't looked for the nearest projecting parent,\n         * false if there is no parent performing layout projection, or a reference\n         * to the projecting parent.\n         */\n        var projectionParent;\n        /**\n         * This is a reference to the visual state of the \"lead\" visual element.\n         * Usually, this will be this visual element. But if it shares a layoutId\n         * with other visual elements, only one of them will be designated lead by\n         * AnimateSharedLayout. All the other visual elements will take on the visual\n         * appearance of the lead while they crossfade to it.\n         */\n        var leadProjection = projection;\n        var leadLatestValues = latestValues;\n        var unsubscribeFromLeadVisualElement;\n        /**\n         * The latest layout measurements and calculated projections. This\n         * is seperate from the target projection data in visualState as\n         * many visual elements might point to the same piece of visualState as\n         * a target, whereas they might each have different layouts and thus\n         * projection calculations needed to project into the same viewport box.\n         */\n        var layoutState = createLayoutState();\n        /**\n         *\n         */\n        var crossfader;\n        /**\n         * Keep track of whether the viewport box has been updated since the\n         * last time the layout projection was re-calculated.\n         */\n        var hasViewportBoxUpdated = false;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        var values = new Map();\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        var valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        var prevMotionValues = {};\n        /**\n         * x/y motion values that track the progress of initiated layout\n         * animations.\n         *\n         * TODO: Target for removal\n         */\n        var projectionTargetProgress;\n        /**\n         * When values are removed from all animation props we need to search\n         * for a fallback value to animate to. These values are tracked in baseTarget.\n         */\n        var baseTarget = __assign({}, latestValues);\n        // Internal methods ========================\n        /**\n         * On mount, this will be hydrated with a callback to disconnect\n         * this visual element from its parent on unmount.\n         */\n        var removeFromVariantTree;\n        /**\n         *\n         */\n        function render() {\n            if (!instance)\n                return;\n            if (element.isProjecting()) {\n                /**\n                 * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n                 * This is the final box that we will then project into by calculating a transform delta and\n                 * applying it to the corrected box.\n                 */\n                applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\n                /**\n                 * Update the delta between the corrected box and the final target box, after\n                 * user-set transforms are applied to it. This will be used by the renderer to\n                 * create a transform style that will reproject the element from its actual layout\n                 * into the desired bounding box.\n                 */\n                updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\n            }\n            triggerBuild();\n            renderInstance(instance, renderState);\n        }\n        function triggerBuild() {\n            var valuesToRender = latestValues;\n            if (crossfader && crossfader.isActive()) {\n                var crossfadedValues = crossfader.getCrossfadeState(element);\n                if (crossfadedValues)\n                    valuesToRender = crossfadedValues;\n            }\n            build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\n        }\n        function update() {\n            lifecycles.notifyUpdate(latestValues);\n        }\n        function updateLayoutProjection() {\n            var delta = layoutState.delta, treeScale = layoutState.treeScale;\n            var prevTreeScaleX = treeScale.x;\n            var prevTreeScaleY = treeScale.x;\n            var prevDeltaTransform = layoutState.deltaTransform;\n            updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\n            hasViewportBoxUpdated &&\n                element.notifyViewportBoxUpdate(leadProjection.target, delta);\n            hasViewportBoxUpdated = false;\n            var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\n            if (deltaTransform !== prevDeltaTransform ||\n                // Also compare calculated treeScale, for values that rely on this only for scale correction\n                prevTreeScaleX !== treeScale.x ||\n                prevTreeScaleY !== treeScale.y) {\n                element.scheduleRender();\n            }\n            layoutState.deltaTransform = deltaTransform;\n        }\n        function updateTreeLayoutProjection() {\n            element.layoutTree.forEach(fireUpdateLayoutProjection);\n        }\n        /**\n         *\n         */\n        function bindToMotionValue(key, value) {\n            var removeOnChange = value.onChange(function (latestValue) {\n                latestValues[key] = latestValue;\n                props.onUpdate && sync.update(update, false, true);\n            });\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n            valueSubscriptions.set(key, function () {\n                removeOnChange();\n                removeOnRenderRequest();\n            });\n        }\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\n         * more a reflection of the test.\n         */\n        var initialMotionValues = scrapeMotionValuesFromProps(props);\n        for (var key in initialMotionValues) {\n            var value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        var isControllingVariants = checkIfControllingVariants(props);\n        var isVariantNode = checkIfVariantNode(props);\n        var element = __assign(__assign({ treeType: treeType, \n            /**\n             * This is a mirror of the internal instance prop, which keeps\n             * VisualElement type-compatible with React's RefObject.\n             */\n            current: null, \n            /**\n             * The depth of this visual element within the visual element tree.\n             */\n            depth: parent ? parent.depth + 1 : 0, parent: parent, children: new Set(), \n            /**\n             * An ancestor path back to the root visual element. This is used\n             * by layout projection to quickly recurse back up the tree.\n             */\n            path: parent ? __spreadArray(__spreadArray([], __read(parent.path)), [parent]) : [], layoutTree: parent ? parent.layoutTree : new FlatTree(), \n            /**\n             *\n             */\n            presenceId: presenceId,\n            projection: projection, \n            /**\n             * If this component is part of the variant tree, it should track\n             * any children that are also part of the tree. This is essentially\n             * a shadow tree to simplify logic around how to stagger over children.\n             */\n            variantChildren: isVariantNode ? new Set() : undefined, \n            /**\n             * Whether this instance is visible. This can be changed imperatively\n             * by AnimateSharedLayout, is analogous to CSS's visibility in that\n             * hidden elements should take up layout, and needs enacting by the configured\n             * render function.\n             */\n            isVisible: undefined, \n            /**\n             * Normally, if a component is controlled by a parent's variants, it can\n             * rely on that ancestor to trigger animations further down the tree.\n             * However, if a component is created after its parent is mounted, the parent\n             * won't trigger that mount animation so the child needs to.\n             *\n             * TODO: This might be better replaced with a method isParentMounted\n             */\n            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), \n            /**\n             * This can be set by AnimatePresence to force components that mount\n             * at the same time as it to mount as if they have initial={false} set.\n             */\n            blockInitialAnimation: blockInitialAnimation, \n            /**\n             * A boolean that can be used to determine whether to respect hover events.\n             * For layout measurements we often have to reposition the instance by\n             * removing its transform. This can trigger hover events, which is\n             * undesired.\n             */\n            isHoverEventsEnabled: true, \n            /**\n             * Determine whether this component has mounted yet. This is mostly used\n             * by variant children to determine whether they need to trigger their\n             * own animations on mount.\n             */\n            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {\n                instance = element.current = newInstance;\n                element.pointTo(element);\n                if (isVariantNode && parent && !isControllingVariants) {\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n                }\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n            },\n            /**\n             *\n             */\n            unmount: function () {\n                cancelSync.update(update);\n                cancelSync.render(render);\n                cancelSync.preRender(element.updateLayoutProjection);\n                valueSubscriptions.forEach(function (remove) { return remove(); });\n                element.stopLayoutAnimation();\n                element.layoutTree.remove(element);\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n                lifecycles.clearAllListeners();\n            },\n            /**\n             * Add a child visual element to our set of children.\n             */\n            addVariantChild: function (child) {\n                var _a;\n                var closestVariantNode = element.getClosestVariantNode();\n                if (closestVariantNode) {\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n                    return function () { return closestVariantNode.variantChildren.delete(child); };\n                }\n            },\n            sortNodePosition: function (other) {\n                /**\n                 * If these nodes aren't even of the same type we can't compare their depth.\n                 */\n                if (!sortNodePosition || treeType !== other.treeType)\n                    return 0;\n                return sortNodePosition(element.getInstance(), other.getInstance());\n            }, \n            /**\n             * Returns the closest variant node in the tree starting from\n             * this visual element.\n             */\n            getClosestVariantNode: function () {\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n            }, \n            /**\n             * A method that schedules an update to layout projections throughout\n             * the tree. We inherit from the parent so there's only ever one\n             * job scheduled on the next frame - that of the root visual element.\n             */\n            scheduleUpdateLayoutProjection: parent\n                ? parent.scheduleUpdateLayoutProjection\n                : function () {\n                    return sync.preRender(element.updateTreeLayoutProjection, false, true);\n                }, \n            /**\n             * Expose the latest layoutId prop.\n             */\n            getLayoutId: function () { return props.layoutId; }, \n            /**\n             * Returns the current instance.\n             */\n            getInstance: function () { return instance; }, \n            /**\n             * Get/set the latest static values.\n             */\n            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, \n            /**\n             * Returns the latest motion value state. Currently only used to take\n             * a snapshot of the visual element - perhaps this can return the whole\n             * visual state\n             */\n            getLatestValues: function () { return latestValues; }, \n            /**\n             * Set the visiblity of the visual element. If it's changed, schedule\n             * a render to reflect these changes.\n             */\n            setVisibility: function (visibility) {\n                if (element.isVisible === visibility)\n                    return;\n                element.isVisible = visibility;\n                element.scheduleRender();\n            },\n            /**\n             * Make a target animatable by Popmotion. For instance, if we're\n             * trying to animate width from 100px to 100vw we need to measure 100vw\n             * in pixels to determine what we really need to animate to. This is also\n             * pluggable to support Framer's custom value types like Color,\n             * and CSS variables.\n             */\n            makeTargetAnimatable: function (target, canMutate) {\n                if (canMutate === void 0) { canMutate = true; }\n                return makeTargetAnimatable(element, target, props, canMutate);\n            },\n            /**\n             * Temporarily suspend hover events while we remove transforms in order to measure the layout.\n             *\n             * This seems like an odd bit of scheduling but what we're doing is saying after\n             * the next render, wait 10 milliseconds before reenabling hover events. Waiting until\n             * the next frame results in missed, valid hover events. But triggering on the postRender\n             * frame is too soon to avoid triggering events with layout measurements.\n             *\n             * Note: If we figure out a way of measuring layout while transforms remain applied, this can be removed.\n             */\n            suspendHoverEvents: function () {\n                element.isHoverEventsEnabled = false;\n                sync.postRender(function () {\n                    return setTimeout(function () { return (element.isHoverEventsEnabled = true); }, 10);\n                });\n            },\n            // Motion values ========================\n            /**\n             * Add a motion value and bind it to this visual element.\n             */\n            addValue: function (key, value) {\n                // Remove existing value if it exists\n                if (element.hasValue(key))\n                    element.removeValue(key);\n                values.set(key, value);\n                latestValues[key] = value.get();\n                bindToMotionValue(key, value);\n            },\n            /**\n             * Remove a motion value and unbind any active subscriptions.\n             */\n            removeValue: function (key) {\n                var _a;\n                values.delete(key);\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n                valueSubscriptions.delete(key);\n                delete latestValues[key];\n                removeValueFromRenderState(key, renderState);\n            }, \n            /**\n             * Check whether we have a motion value for this key\n             */\n            hasValue: function (key) { return values.has(key); }, \n            /**\n             * Get a motion value for this key. If called with a default\n             * value, we'll create one if none exists.\n             */\n            getValue: function (key, defaultValue) {\n                var value = values.get(key);\n                if (value === undefined && defaultValue !== undefined) {\n                    value = motionValue(defaultValue);\n                    element.addValue(key, value);\n                }\n                return value;\n            }, \n            /**\n             * Iterate over our motion values.\n             */\n            forEachValue: function (callback) { return values.forEach(callback); }, \n            /**\n             * If we're trying to animate to a previously unencountered value,\n             * we need to check for it in our state and as a last resort read it\n             * directly from the instance (which might have performance implications).\n             */\n            readValue: function (key) { var _a; return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options); }, \n            /**\n             * Set the base target to later animate back to. This is currently\n             * only hydrated on creation and when we first read a value.\n             */\n            setBaseTarget: function (key, value) {\n                baseTarget[key] = value;\n            },\n            /**\n             * Find the base target for a value thats been removed from all animation\n             * props.\n             */\n            getBaseTarget: function (key) {\n                if (getBaseTarget) {\n                    var target = getBaseTarget(props, key);\n                    if (target !== undefined && !isMotionValue(target))\n                        return target;\n                }\n                return baseTarget[key];\n            } }, lifecycles), { \n            /**\n             * Build the renderer state based on the latest visual state.\n             */\n            build: function () {\n                triggerBuild();\n                return renderState;\n            },\n            /**\n             * Schedule a render on the next animation frame.\n             */\n            scheduleRender: function () {\n                sync.render(render, false, true);\n            }, \n            /**\n             * Synchronously fire render. It's prefered that we batch renders but\n             * in many circumstances, like layout measurement, we need to run this\n             * synchronously. However in those instances other measures should be taken\n             * to batch reads/writes.\n             */\n            syncRender: render, \n            /**\n             * Update the provided props. Ensure any newly-added motion values are\n             * added to our map, old ones removed, and listeners updated.\n             */\n            setProps: function (newProps) {\n                props = newProps;\n                lifecycles.updatePropListeners(newProps);\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n            }, getProps: function () { return props; }, \n            // Variants ==============================\n            /**\n             * Returns the variant definition with a given name.\n             */\n            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, \n            /**\n             * Returns the defined default transition on this component.\n             */\n            getDefaultTransition: function () { return props.transition; }, \n            /**\n             * Used by child variant nodes to get the closest ancestor variant props.\n             */\n            getVariantContext: function (startAtParent) {\n                if (startAtParent === void 0) { startAtParent = false; }\n                if (startAtParent)\n                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n                if (!isControllingVariants) {\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n                    if (props.initial !== undefined) {\n                        context_1.initial = props.initial;\n                    }\n                    return context_1;\n                }\n                var context = {};\n                for (var i = 0; i < numVariantProps; i++) {\n                    var name_1 = variantProps[i];\n                    var prop = props[name_1];\n                    if (isVariantLabel(prop) || prop === false) {\n                        context[name_1] = prop;\n                    }\n                }\n                return context;\n            },\n            // Layout projection ==============================\n            /**\n             * Enable layout projection for this visual element. Won't actually\n             * occur until we also have hydrated layout measurements.\n             */\n            enableLayoutProjection: function () {\n                projection.isEnabled = true;\n                element.layoutTree.add(element);\n            },\n            /**\n             * Lock the projection target, for instance when dragging, so\n             * nothing else can try and animate it.\n             */\n            lockProjectionTarget: function () {\n                projection.isTargetLocked = true;\n            },\n            unlockProjectionTarget: function () {\n                element.stopLayoutAnimation();\n                projection.isTargetLocked = false;\n            }, getLayoutState: function () { return layoutState; }, setCrossfader: function (newCrossfader) {\n                crossfader = newCrossfader;\n            }, isProjecting: function () { return projection.isEnabled && layoutState.isHydrated; }, \n            /**\n             * Start a layout animation on a given axis.\n             */\n            startLayoutAnimation: function (axis, transition, isRelative) {\n                if (isRelative === void 0) { isRelative = false; }\n                var progress = element.getProjectionAnimationProgress()[axis];\n                var _a = isRelative\n                    ? projection.relativeTarget[axis]\n                    : projection.target[axis], min = _a.min, max = _a.max;\n                var length = max - min;\n                progress.clearListeners();\n                progress.set(min);\n                progress.set(min); // Set twice to hard-reset velocity\n                progress.onChange(function (v) {\n                    element.setProjectionTargetAxis(axis, v, v + length, isRelative);\n                });\n                return element.animateMotionValue(axis, progress, 0, transition);\n            },\n            /**\n             * Stop layout animations.\n             */\n            stopLayoutAnimation: function () {\n                eachAxis(function (axis) {\n                    return element.getProjectionAnimationProgress()[axis].stop();\n                });\n            },\n            /**\n             * Measure the current viewport box with or without transforms.\n             * Only measures axis-aligned boxes, rotate and skew must be manually\n             * removed with a re-render to work.\n             */\n            measureViewportBox: function (withTransform) {\n                if (withTransform === void 0) { withTransform = true; }\n                var viewportBox = measureViewportBox(instance, options);\n                if (!withTransform)\n                    removeBoxTransforms(viewportBox, latestValues);\n                return viewportBox;\n            },\n            /**\n             * Get the motion values tracking the layout animations on each\n             * axis. Lazy init if not already created.\n             */\n            getProjectionAnimationProgress: function () {\n                projectionTargetProgress || (projectionTargetProgress = {\n                    x: motionValue(0),\n                    y: motionValue(0),\n                });\n                return projectionTargetProgress;\n            },\n            /**\n             * Update the projection of a single axis. Schedule an update to\n             * the tree layout projection.\n             */\n            setProjectionTargetAxis: function (axis, min, max, isRelative) {\n                if (isRelative === void 0) { isRelative = false; }\n                var target;\n                if (isRelative) {\n                    if (!projection.relativeTarget) {\n                        projection.relativeTarget = axisBox();\n                    }\n                    target = projection.relativeTarget[axis];\n                }\n                else {\n                    projection.relativeTarget = undefined;\n                    target = projection.target[axis];\n                }\n                target.min = min;\n                target.max = max;\n                // Flag that we want to fire the onViewportBoxUpdate event handler\n                hasViewportBoxUpdated = true;\n                lifecycles.notifySetAxisTarget();\n            },\n            /**\n             * Rebase the projection target on top of the provided viewport box\n             * or the measured layout. This ensures that non-animating elements\n             * don't fall out of sync differences in measurements vs projections\n             * after a page scroll or other relayout.\n             */\n            rebaseProjectionTarget: function (force, box) {\n                if (box === void 0) { box = layoutState.layout; }\n                var _a = element.getProjectionAnimationProgress(), x = _a.x, y = _a.y;\n                var shouldRebase = !projection.relativeTarget &&\n                    !projection.isTargetLocked &&\n                    !x.isAnimating() &&\n                    !y.isAnimating();\n                if (force || shouldRebase) {\n                    eachAxis(function (axis) {\n                        var _a = box[axis], min = _a.min, max = _a.max;\n                        element.setProjectionTargetAxis(axis, min, max);\n                    });\n                }\n            },\n            /**\n             * Notify the visual element that its layout is up-to-date.\n             * Currently Animate.tsx uses this to check whether a layout animation\n             * needs to be performed.\n             */\n            notifyLayoutReady: function (config) {\n                setCurrentViewportBox(element);\n                element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\n            }, \n            /**\n             * Temporarily reset the transform of the instance.\n             */\n            resetTransform: function () { return resetTransform(element, instance, props); }, restoreTransform: function () { return restoreTransform(instance, renderState); }, updateLayoutProjection: updateLayoutProjection,\n            updateTreeLayoutProjection: function () {\n                element.layoutTree.forEach(fireResolveRelativeTargetBox);\n                /**\n                 * Schedule the projection updates at the end of the current preRender\n                 * step. This will ensure that all layout trees will first resolve\n                 * relative projection boxes into viewport boxes, and *then*\n                 * update projections.\n                 */\n                sync.preRender(updateTreeLayoutProjection, false, true);\n            },\n            getProjectionParent: function () {\n                if (projectionParent === undefined) {\n                    var foundParent = false;\n                    // Search backwards through the tree path\n                    for (var i = element.path.length - 1; i >= 0; i--) {\n                        var ancestor = element.path[i];\n                        if (ancestor.projection.isEnabled) {\n                            foundParent = ancestor;\n                            break;\n                        }\n                    }\n                    projectionParent = foundParent;\n                }\n                return projectionParent;\n            },\n            resolveRelativeTargetBox: function () {\n                var relativeParent = element.getProjectionParent();\n                if (!projection.relativeTarget || !relativeParent)\n                    return;\n                calcRelativeBox(projection, relativeParent.projection);\n                if (relativeParent.getProps().drag) {\n                    var target = projection.target;\n                    applyBoxTransforms(target, target, relativeParent.getLatestValues());\n                }\n            },\n            /**\n             *\n             */\n            pointTo: function (newLead) {\n                leadProjection = newLead.projection;\n                leadLatestValues = newLead.getLatestValues();\n                /**\n                 * Subscribe to lead component's layout animations\n                 */\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n                unsubscribeFromLeadVisualElement = pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\n                    var _a;\n                    if (element.isPresent) {\n                        element.presence = Presence.Present;\n                    }\n                    else {\n                        (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\n                    }\n                }));\n            }, \n            // TODO: Clean this up\n            isPresent: true, presence: Presence.Entering });\n        return element;\n    };\n};\nfunction fireResolveRelativeTargetBox(child) {\n    child.resolveRelativeTargetBox();\n}\nfunction fireUpdateLayoutProjection(child) {\n    child.updateLayoutProjection();\n}\nvar variantProps = __spreadArray([\"initial\"], __read(variantPriorityOrder));\nvar numVariantProps = variantProps.length;\n\nexport { visualElement };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}